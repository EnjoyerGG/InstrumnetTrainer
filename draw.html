<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Draw Mode</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
            background: #000;
            color: #fff;
            font: 14px/1.6 system-ui, Segoe UI, Arial
        }

        /* 两层画布：背景频谱在下，绘画在上 */
        #bg,
        #draw {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block
        }

        #bg {
            z-index: 0
        }

        #draw {
            z-index: 1;
            cursor: crosshair
        }

        /* 启动遮罩 */
        #start {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, .65);
            z-index: 2
        }

        #btn {
            appearance: none;
            border: 0;
            border-radius: 999px;
            padding: .9rem 1.4rem;
            background: #1e90ff;
            color: #fff;
            font-weight: 700;
            letter-spacing: .5px;
            cursor: pointer
        }

        /* 提示文字 */
        #hint {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
            pointer-events: none;
            color: #fff;
            mix-blend-mode: screen;
            opacity: .9;
            transition: opacity .4s
        }

        #hint.gone {
            opacity: 0
        }
    </style>
</head>

<body>

    <canvas id="bg"></canvas>
    <canvas id="draw"></canvas>

    <div id="hint">Draw on me</div>

    <div id="start"><button id="btn" autofocus>Tap to start</button></div>

    <script>
        /* ============ 基础工具 ============ */
        const REACT_GAIN = 380;
        const REACT_POW = 0.60;
        const params = new URLSearchParams(location.search);
        const mode = Math.max(0, Math.min(3, parseInt(params.get('mode') || '0', 10)));
        const STAR_SPEED_SCALE = 1.35; // 小于 1 → 整体变慢
        const STAR_RADIUS_GAIN = 0.04; // 由 0.10 降到 0.04 → 变小
        const STAR_ACCEL = 0.0018;
        const SONGS = [ // 与 drawingMode.js 保持一致的内部资源路径
            'assets/songs/song1.mp3',
            'assets/songs/song2.mp3',
            'assets/songs/song3.mp3',
            'assets/songs/song4.mp3'
        ]; // :contentReference[oaicite:2]{index=2}

        // 粒子喷泉（替代原来的线段 segments）
        const EMIT_INTERVAL_MS = 12;
        const NOTE_LIFE = 1600; // 1.6s，整体 1.6~2.4s 后消失
        const NOTE_COLORS = ['#ff4d4f', '#2d8cff', '#22c55e', '#ffd84d', '#ff7ae0'];
        let particles = [];
        let lastEmit = 0;

        /* ============ WebAudio：同一套音频用于播放 + 频谱 ============ */
        let actx, analyser, gainNode, source = null, songBuffer = null;
        // let playing = false, // 是否正在发声
        //     startedAt = 0,   // 当前这次start的绝对时间(ms)
        //     offset = 0;      // 已播放位置(秒)，暂停时保留
        let audioReady = false;

        async function initAudio() {
            actx = new (window.AudioContext || window.webkitAudioContext)();

            analyser = actx.createAnalyser();
            analyser.fftSize = 1024;
            analyser.minDecibels = -110;
            analyser.maxDecibels = -10;
            analyser.smoothingTimeConstant = 0.08; // 更敏感

            gainNode = actx.createGain();
            gainNode.gain.value = 0.0; // 初始静音
            gainNode.connect(analyser);
            analyser.connect(actx.destination);

            // 载入内部歌曲（仍用你 ?mode 的 SONGS）
            const url = SONGS[mode] || SONGS[0];
            const res = await fetch(url);
            const buf = await res.arrayBuffer();
            songBuffer = await actx.decodeAudioData(buf);

            // ★只创建一次的 BufferSource：循环播放，不再停止
            source = actx.createBufferSource();
            source.buffer = songBuffer;
            source.loop = true;
            source.connect(gainNode);
            source.start(); // 一直走，只靠 gain 静音/发声

            audioReady = true;
        }

        function fadeTo(value, ms) {
            if (!actx) return;
            const now = actx.currentTime;
            const v = Math.max(0, Math.min(1, value));
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            gainNode.gain.linearRampToValueAtTime(v, now + ms / 1000);
        }

        function resumePlayback() {
            if (!audioReady) return;
            fadeTo(1.0, 220); // 淡入
        }

        function pausePlayback() {
            if (!audioReady) return;
            fadeTo(0.0, 260); // 淡出（但不停止 Source）
        }

        // function createAndStartSource(startAtSeconds) {
        //     // 每次恢复播放都要新建一个 BufferSource
        //     stopSource();
        //     source = actx.createBufferSource();
        //     source.buffer = songBuffer;
        //     source.connect(gainNode);
        //     source.start(0, startAtSeconds);
        //     startedAt = actx.currentTime * 1000; // 记录开始时间(ms)
        //     playing = true;
        // }

        // function stopSource() {
        //     if (source) {
        //         try { source.stop(); } catch (e) { }
        //         source.disconnect();
        //         source = null;
        //     }
        //     playing = false;
        // }

        // function fadeTo(value, ms) {
        //     const now = actx.currentTime;
        //     const target = Math.max(0, Math.min(1, value));
        //     gainNode.gain.cancelScheduledValues(now);
        //     gainNode.gain.setValueAtTime(gainNode.gain.value, now);
        //     gainNode.gain.linearRampToValueAtTime(target, now + ms / 1000);
        // }

        // function resumePlayback() {
        //     // 从 offset 位置继续播放并淡入
        //     createAndStartSource(offset);
        //     fadeTo(1.0, 350);
        // }

        // function pausePlayback() {
        //     // 先淡出，再停止并累加 offset
        //     const before = actx.currentTime;
        //     fadeTo(0.0, 350);
        //     setTimeout(() => {
        //         if (playing) {
        //             const now = actx.currentTime;
        //             // 累加已播放时长
        //             const elapsed = now - before;
        //             offset += elapsed; // 单位秒
        //             stopSource();
        //         }
        //     }, 360);
        // }

        /* ============ 背景：星空 + 中央波形，使用同一个 analyser ============ */
        const bg = document.getElementById('bg');
        const g = bg.getContext('2d', { alpha: false });
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        let W = 0, H = 0, CX = 0, CY = 0, rotation = 0;
        let freqData, timeData, avg = 0;
        const TOTAL_STARS = 1200;
        const stars = [];
        function resize() {
            W = bg.width = Math.floor(innerWidth * dpr);
            H = bg.height = Math.floor(innerHeight * dpr);
            g.setTransform(1, 0, 0, 1, 0, 0);
            g.scale(dpr, dpr);
            CX = innerWidth / 2; CY = innerHeight / 2;
        }
        addEventListener('resize', resize);

        function Star() {
            this.x = Math.random() * innerWidth - CX;
            this.y = Math.random() * innerHeight - CY;
            this.z = this.max_depth = Math.max(innerWidth / innerHeight);
            const bigger = Math.abs(this.x) > Math.abs(this.y);
            this.dx = (bigger ? 1 : Math.abs(this.x / this.y)) * (this.x > 0 ? 1 : -1);
            this.dy = (bigger ? Math.abs(this.y / this.x) : 1) * (this.y > 0 ? 1 : -1);
            this.dz = -0.1;
            this.ddx = STAR_ACCEL * this.dx;
            this.ddy = STAR_ACCEL * this.dy;
            this.radius = 0.2;
            this.color = "#465677";
        }
        function initStars() {
            stars.length = 0; for (let i = 0; i < TOTAL_STARS; i++) stars.push(new Star());
        }
        function bgClear() {
            const grd = g.createLinearGradient(0, 0, 0, innerHeight);
            grd.addColorStop(0, "#000011"); grd.addColorStop(0.96, "#060D1F"); grd.addColorStop(1, "#02243F");
            g.globalCompositeOperation = "source-over";
            g.fillStyle = grd; g.fillRect(0, 0, innerWidth, innerHeight);
        }
        function drawStars() {
            const hit = avg > 100;
            for (let i = 0; i < stars.length; i++) {
                const p = stars[i];
                const tick = (avg > 100) ? (avg / 20) * STAR_SPEED_SCALE : (avg / 50) * STAR_SPEED_SCALE;
                p.x += p.dx * tick; p.y += p.dy * tick; p.z += p.dz;
                p.dx += p.ddx; p.dy += p.ddy;
                p.radius = 0.2 + ((p.max_depth - p.z) * STAR_RADIUS_GAIN);
                if (p.x < -CX || p.x > CX || p.y < -CY || p.y > CY) { stars[i] = new Star(); continue; }
                g.beginPath(); g.globalCompositeOperation = "lighter"; g.fillStyle = p.color;
                g.arc(p.x + CX, p.y + CY, p.radius, 0, Math.PI * 2); g.fill();
            }
        }
        function drawAvgCircle() {
            g.strokeStyle = "rgba(77,218,248,1)"; g.fillStyle = "rgba(29,36,57,0.08)";
            g.lineWidth = 1; g.beginPath(); g.arc(CX, CY, (avg + Math.max(innerWidth, innerHeight) / 12) / dpr, 0, Math.PI * 2);
            g.stroke(); g.fill();
        }
        const FFT_POINTS = 1024 / 2;
        const ring = new Array(FFT_POINTS).fill(0).map((_, i) => ({ angle: i * 360 / FFT_POINTS, x: 0, y: 0, dx: 0, dy: 0 }));
        function drawWave() {
            rotation += (avg > 100) ? 0.06 : -0.06;
            g.strokeStyle = (avg > 100) ? "rgba(157,242,157,0.8)" : "rgba(157,242,157,0.11)";
            g.lineWidth = 1; g.lineCap = "round";

            g.save(); g.translate(CX, CY); g.rotate(rotation); g.translate(-CX, -CY);
            g.beginPath();
            for (let i = 0; i < ring.length; i++) {
                const p = ring[i];
                const baseR = Math.max(innerWidth, innerHeight) / 10;
                const v = timeData ? timeData[i] : 128;
                const a = Math.PI / 180 * p.angle;

                // ★ 去直流（围绕 0）+ 灵敏度增益
                const amp = (v - 128) / 128;         // -1..1
                const disp = amp * REACT_GAIN;       // 放大位移

                p.x = CX + baseR * Math.sin(a);
                p.y = CY + baseR * Math.cos(a);
                p.dx = p.x + disp * Math.sin(a);   // ★ 用 disp
                p.dy = p.y + disp * Math.cos(a);   // ★ 用 disp

                const n = ring[(i + 1) % ring.length];
                const xc = (p.dx + (n.dx || n.x)) / 2, yc = (p.dy + (n.dy || n.y)) / 2;
                if (i === 0) g.moveTo(p.dx, p.dy);
                g.quadraticCurveTo(p.dx, p.dy, xc, yc);
            }
            g.stroke(); g.restore();
        }

        function drawSegments() {
            ctx.clearRect(0, 0, draw.width, draw.height);
            const now = performance.now();

            // 用音乐的平均能量调线宽/辉光
            const volume = avg / 255;  // 0..1 （avg 已在背景频谱里算好）
            const baseWidth = 2 + volume * 18;

            for (let i = segments.length - 1; i >= 0; i--) {
                const s = segments[i];
                const age = now - s.t0;
                if (age >= s.life) { segments.splice(i, 1); continue; }

                // α 随时间线性衰减（可换 ease）
                const alpha = 1 - age / s.life;

                // 颜色随时间轻微变换
                const hue = (s.t0 / 30) % 360;
                ctx.lineWidth = baseWidth * (0.7 + 0.3 * alpha);
                ctx.strokeStyle = `hsla(${hue}, ${60 + volume * 40}%, 50%, ${alpha})`;
                ctx.shadowColor = `hsla(${hue}, 80%, 60%, ${alpha * 0.9})`;
                ctx.shadowBlur = 6 + volume * 12;

                ctx.beginPath();
                ctx.moveTo(s.x1, s.y1);
                ctx.lineTo(s.x2, s.y2);
                ctx.stroke();
            }

            requestAnimationFrame(drawSegments);
        }

        function animateBG() {
            requestAnimationFrame(animateBG);
            if (!analyser) return;
            if (!freqData) { freqData = new Uint8Array(analyser.frequencyBinCount); timeData = new Uint8Array(analyser.frequencyBinCount); }
            analyser.getByteFrequencyData(freqData);
            analyser.getByteTimeDomainData(timeData);
            // 平均值
            let sum = 0; for (let i = 0; i < freqData.length; i++) sum += freqData[i];
            avg = sum / freqData.length;

            bgClear(); drawStars(); drawAvgCircle(); drawWave();
        }

        /* ============ 前景绘画：按住时淡入播放，松开/不动后淡出并暂停 ============ */
        const draw = document.getElementById('draw');
        const ctx = draw.getContext('2d');
        const dpr2 = Math.min(2, window.devicePixelRatio || 1);
        const STROKE_LIFE_MIN = 1.2;
        const STROKE_LIFE_MAX = 2.8;
        let drawing = false, lastX = 0, lastY = 0, idleTimer = null;
        const segments = [];

        function resizeDraw() {
            draw.width = innerWidth * dpr2;
            draw.height = innerHeight * dpr2;
            ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.scale(dpr2, dpr2);
        }
        //addEventListener('resize', () => { resizeDraw(); });
        addEventListener('resize', resizeDraw);

        function startStroke(x, y) {
            document.getElementById('hint').classList.add('gone');
            drawing = true; lastX = x; lastY = y;
            ensurePlaying();
        }
        function moveStroke(x, y) {
            if (!drawing) return;

            const now = performance.now();
            const dx = x - lastX, dy = y - lastY;
            const dist = Math.hypot(dx, dy) || 1;
            const volume = avg / 255;                   // 来自频谱平均值
            const speed = 0.25 + volume * 2.8;         // 音乐越强，喷射越快

            if (now - lastEmit > EMIT_INTERVAL_MS) {
                particles.push({
                    x, y,
                    vx: (dx / dist) * speed * 3 + (Math.random() - 0.5) * speed,
                    vy: (dy / dist) * speed * 3 + (Math.random() - 0.5) * speed,
                    t0: now,
                    life: NOTE_LIFE * (0.8 + Math.random() * 0.5), // 1.28~2.4s
                    size: 10 + volume * 28,
                    char: Math.random() < 0.15 ? '♫' : '♪',
                    color: NOTE_COLORS[Math.floor(Math.random() * NOTE_COLORS.length)]
                });
                lastEmit = now;
            }

            lastX = x; lastY = y;
            ensurePlaying(); // 只淡入
        }

        function endStroke() {
            drawing = false;
            schedulePause();
        }

        function drawFront() {
            ctx.clearRect(0, 0, draw.width, draw.height);
            const now = performance.now();

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                const age = now - p.t0;
                if (age >= p.life) { particles.splice(i, 1); continue; }

                // 更新位置（向外扩散更快）
                p.x += p.vx;
                p.y += p.vy;

                // 淡出
                const alpha = 1 - age / p.life;

                ctx.save();
                ctx.globalAlpha = Math.max(0, alpha);
                ctx.font = `${p.size}px "Segoe UI Symbol","Arial Unicode MS", Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 8 + (avg / 255) * 14;
                ctx.shadowColor = p.color;
                ctx.fillText(p.char, p.x, p.y);
                ctx.restore();
            }

            requestAnimationFrame(drawFront);
        }

        function ensurePlaying() {
            if (!audioReady) return;
            if (idleTimer) { clearTimeout(idleTimer); idleTimer = null; }
            fadeTo(1.0, 200);     // 只淡入，不重建 source
        }

        function schedulePause() {
            if (!audioReady) return;
            if (idleTimer) clearTimeout(idleTimer);
            idleTimer = setTimeout(() => { fadeTo(0.0, 260); }, 600);  // 只淡出，不 stop
        }

        // 鼠标
        draw.addEventListener('mousedown', e => startStroke(e.clientX, e.clientY));
        draw.addEventListener('mousemove', e => moveStroke(e.clientX, e.clientY));
        addEventListener('mouseup', endStroke);
        draw.addEventListener('mouseleave', endStroke);
        // 触摸
        draw.addEventListener('touchstart', e => { const t = e.touches[0]; startStroke(t.clientX, t.clientY); }, { passive: false });
        draw.addEventListener('touchmove', e => { const t = e.touches[0]; moveStroke(t.clientX, t.clientY); e.preventDefault(); }, { passive: false });
        draw.addEventListener('touchend', endStroke);

        /* ============ 启动 ============ */
        document.getElementById('btn').addEventListener('click', async () => {
            document.getElementById('start').style.display = 'none';
            resize(); initStars(); resizeDraw();
            await initAudio();       // 载入内部歌曲（按 ?mode）
            animateBG();             // 开始可视化动画（使用同一个 analyser）
            drawFront();
            // 注意：不自动播放，需按住开始画才会淡入恢复播放
        });
    </script>
</body>

</ht